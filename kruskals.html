<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="AlgoVis - Online Algorithm Visualization">
  <meta name="author" content="Tobias Nöthlich">
  <title>AlgoVis - Online Algorithm Visualization</title>
  
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
  <link href="https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Roboto+Mono:wght@600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-slider/11.0.2/css/bootstrap-slider.min.css">
  <link rel="stylesheet" href="css/main.css">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
</head>

<body class="scroll">
  <header class="page-header w-100" >
    <div class="container-fluid">
      <nav id="navbar" class="navbar navbar-expand-lg navbar-dark">
        <a class="btn back-button navbar-brand" href="sorting.html"><i class="fa fa-arrow-left white-text" aria-hidden="true"></i> Back</a>
          <span class="w-100 text-center white-text" style="font-size: x-large; font-weight: bold;">
            Kruskal's MST Visualization
          </span>
        </div>
        
      </nav>
    </div>
  </header>

  <div class="container-fluid px-0 mt-0" >
    <div class="row w-100 mx-auto">
        <div class="col-10 mx-0 px-0">
            <span class="large-text logo-font">Draw your graph:</span>
        </div>
        <div class="col-2 mr-0 px-0 my-0 py-0 text-right"> <button onclick="clearCanvas()" class="button-top">Clear</button><button class="button-top ml-1" onclick="randomGraph()">Random</button></div>
        </div>
    <div class="data-container border-dark-nb p-1 mb-0 mt-0 w-100">
      <svg id="visu"></svg>
    </div>
    <div class="w-100 row mx-auto border-dark-nt my-0 py-0"><p id="nodes" class="my-0 py-0"></p></div>
    <div class="row mx-auto">
      <div class="col-sm-12 col-md-12 col-lg-6 px-0 mr-0">
        <div class="ide w-100">
          <div class="row ml-auto mr-auto 1">
            <span>q = graph.getEdges().sortAscending()</span>
          </div>
          <div class="row ml-auto mr-auto mt-1 2 ">
            <span>mst = []</span>
          </div>
          <div class="row ml-auto mr-auto mt-1 3 ">
            <span><span class="op">while</span>(mst < graph.numVertices()-1)</span>
          </div>
          <div class="row ml-auto mr-auto mt-1 4 ">
            <span>&emsp;&emsp;next = q.popFirst()</span>
          </div>
          <div class="row ml-auto mr-auto mt-1 5">
            <span>&emsp;&emsp;<span class="op">if</span>(!formsCycle(mst, next))</span>
          </div>
          <div class="row ml-auto mr-auto mt-1 6">
            <span>&emsp;&emsp;&emsp;&emsp;mst.push(next)</span>
          </div>
      </div>
    </div>
    <div class="col-sm-12 col-md-12 col-lg-6 ml-0 px-0">
      <div class="ide w-100 pl-0">
        <div class="row ml-auto mr-auto">
          <span class="comment w-100">SHORT EXPLANATION</span>
        </div>
        <div class="row ml-auto mr-auto mt-1">
          <span class="comment w-100">---------------------</span>
        </div>
        <div class="row ml-auto mr-auto mt-1">
          <span class="comment">1. Sort all edges by weight (non-decreasing).</span>
        </div>
        <div class="row ml-auto mr-auto mt-1">
          <span class="comment">2. Pick the edge with the smallest weight.</span>
        </div>
        <div class="row ml-auto mr-auto mt-1">
          <span class="comment">3. Check if adding that edge to the MST forms a cycle. If it doesn't, add it.</span>
        </div>
        <div class="row ml-auto mr-auto mt-1">
          <span class="comment">4. Repeat steps 2 and 3 until MST has a lenght of (number of Vertices - 1).</span>
        </div>
        
      </div>
    </div>
  </div>
    <hr data-content="Instructions" class="hr-text mb-3 mt-4">
    <div class="row mx-auto">
      <div class="col-sm-12 col-md-12 col-lg-6">
        <form>
          <div class="row">
              <div class="col-12">
                  To draw a new vertex, simply click anywhere on the canvas above.<br>
                  To create an edge between two vertices, click on the first vertex and then on the second one.<br>
                  You can create a random graph by clicking on the 'Random' button above the canvas.<br>
                  To clear the canvas, use the 'Clear' button.
                  
              </div>
          </div>
        </form>
      </div>
      <div class="col-sm-12 col-md-12 col-lg-6">
        <form>
          <div class="form-group row">
            <div class="col-sm-5">Speed: </div>
            <div class="col-sm-7">
              <span>Slow&emsp;</span>
              <input id="speedslider" data-slider-id='speedSlider' type="text" data-slider-min="350" data-slider-max="1000" data-slider-step="10" data-slider-value="500"/>
              <span>&emsp;Fast</span>
            </div>
          </div>
          <div class="form-group row">
            <div class="col-sm-12">
              <button id="start-button" type="button" onclick="kruskals()" class="btn btn-danger highlighted-bg w-100">Start</button>
            </div>
          </div>
        </form>
      </div>
    </div>
</div>

<footer class="pt-5 page-footer">
  <div class="container-fluid">
    <div class="row">
      <div class="col-12 col-md-6 footer-child copyright">
        AlgoVis © 2020 All Rights Reserved
      </div>
      <div class="col-12 col-md-6 footer-child footer-links">
        <a href="" class="mr-3">Privacy Policy</a>
        <a href="">FAQ</a>
        <div>
          <small>Made with <i class="fa fa-heart highlighted-text"></i> by <a href="http://tobinatore.github.io/" target="_blank">Tobias Nöthlich</a>
          </small>
        </div>
      </div>
    </div>
  </div>
</footer>


<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-slider/11.0.2/bootstrap-slider.min.js"></script>
<script src="https://d3js.org/d3.v5.js"></script>
<script src="js/graph.js"></script>
<script src="js/union-find.js"></script>

<script>
    const container = document.querySelector(".data-container");
    var FLAG = false;
    var DELAY = 500;
    var w = globalThis.screen.availWidth;
    var h = 370;
    var data_nodes = [];
    var data_edges = [];
    var radius = 25;
    var strokeWidth = "5px";
    var drawing = false;
    var xy0;
    var xy1;
    var g = new WeightedUndirectedGraph();
    var vertexCount = 0;
    var firstVert;
    var secVert;
    var visited = [];
    var drawGraph = false;
    var running = false;

    function setDelay(delay){
        DELAY = delay;
    }
    
    var xScale = d3.scaleLinear()
        .domain([0, w])
        .range([0, w]);  

            
    var yScale = d3.scaleLinear()
        .domain([0, h])
        .range([0, h]);  // Set margins for y specific

    var svg = d3.select("#visu");
        svg.append("g").attr("id", "g-paths");

    svg.on("click", async function() {
      if(!running){
        var coords = d3.mouse(this);
        drawing = false;
        await newVertex(coords); 
      }                   
    });

    async function newVertex(coords){
        return new Promise(resolve => {
            var newData= {
                x: Math.round( xScale.invert(coords[0])),  // Takes the pixel number to convert to number
                y: Math.round( yScale.invert(coords[1]))
            };


            data_nodes.push(newData);   // Push data to our array
            g.addVertex(vertexCount++);

            var groups = svg.selectAll("circle")  // For new circle, go through the update process
                .data(data_nodes)
                .enter()
                .append("g")
                .attr("id", function(d,i){return "g"+i;})
            groups.append("circle")
                .attr("cx", function(d) { return xScale(d.x); })  // Get attributes from circleAttrs var
                .attr("cy", function(d) { return yScale(d.y); })
                .transition()
                .duration(500)
                .attr("r", radius)
                .attr("fill", "white")
                .attr("stroke", "black")
                .attr("stroke-width", strokeWidth)
                .attr("id", function(d,i){return "circle"+i;})                
            setTimeout(() => {  
                groups.append("text")
                .text(function(d,i){return i;})
                .attr("x", function(d) { return xScale(d.x)-5; })  // Get attributes from circleAttrs var
                .attr("y", function(d) { return yScale(d.y)+5; })
                .attr("font-family", "sans-serif")
                .attr("font-size", "18px")
                .attr("font-weight", "bold");
            }, 300);
            groups.on("click", function(d,i){
                var e = d3.event;
                e.cancelBubble = true;
                if (e.stopPropagation) e.stopPropagation();
                if(!running){
                if(!drawing){
                    drawing = true;
                    var choords = d3.mouse(this);
                    xy0= {
                        x: Math.round( xScale.invert(coords[0])),  // Takes the pixel number to convert to number
                        y: Math.round( yScale.invert(coords[1]))
                    };
                    firstVert = i;
                    svg.select("#circle"+i).attr("stroke", "#FF3D2E");
                }
                else{
                    //drawing = false;
                    var choords = d3.mouse(this);
                    secVert = i;
                    xy1= {
                        x: Math.round( xScale.invert(coords[0])),  // Takes the pixel number to convert to number
                        y: Math.round( yScale.invert(coords[1]))
                    };
                    var line = d3.line()
                        .x(function(d) { return d.x; })
                        .y(function(d) { return d.y; })
                        .curve(d3.curveLinear);                        
                    if(xy0.x != xy1.x || xy0.y != xy1.y){
                        if(!g.edgeExists(data_nodes[firstVert],data_nodes[secVert])){
                            g.addEdge({ x:data_nodes[firstVert].x, y:data_nodes[firstVert].y, id:firstVert }, {x:data_nodes[secVert].x, y:data_nodes[secVert].y, id:secVert});
                            svg.select("#g-paths").append("path")
                                .transition()
                                .duration(300)
                                .attr("d", line([xy0,xy1]))
                                .attr("stroke", "#272F32")
                                .attr("stroke-width", 4)
                                .attr("fill", "none")
                                .attr("id", function(d,i){
                                    data_edges.push({v1:firstVert, v2:secVert, id:data_edges.length});
                                    return "path"+(data_edges.length-1);
                                });
                            var text = svg.append("g").attr("id", "text-path-"+firstVert+""+secVert)
                                .append("text")
                                .append("textPath") //append a textPath to the text element
                                .attr("xlink:href", "#path"+(data_edges.length-1)) //place the ID of the path here
                                .style("text-anchor","middle") //place the text halfway on the arc
                                .attr("startOffset", "50%")
                                .attr("font-size", "18px")
                                .attr("font-weight", "bold")
                                .text(g.getEdgeLength(firstVert,secVert))
                        }
                    }
                    drawing = false;
                    svg.select("#circle"+firstVert).attr("stroke", "black");
                    svg.select("#circle"+secVert).attr("stroke", "black");
                    setTimeout(() =>{
                      
                    svg.select("#text-path-"+firstVert+""+secVert).attr('transform', function(d) {
                        if (!(isVector(data_nodes[firstVert]) && isVector(data_nodes[secVert]))) {
                            return '';
                        }
                        // Get the geometric center of this element
                        var box = this.getBBox();
                        var center = {
                            x: box.x + box.width / 2,
                            y: box.y + box.height / 2
                        };

                        // Get the vector of the link
                        var delta = {
                            x: data_nodes[secVert].x - data_nodes[firstVert].x,
                            y: data_nodes[secVert].y - data_nodes[firstVert].y
                        };

                        // Get a unitary vector orthogonal to delta
                        var norm = Math.sqrt(delta.x * delta.x + delta.y * delta.y);
                        var orth = {
                            x: delta.y/norm,
                            y: -delta.x/norm
                        };

                        // Replace this with your ACTUAL font size
                        // Needed to calculate the offset later, so the 
                        // text doesn't clip the path
                        var fontSize = 18;

                        // Flip the text and translate it beyond the link line
                        // if the link goes towards the left
                        return delta.x < 0
                            ? ('rotate(180 '
                            + center.x
                            + ' ' + center.y
                            + ') translate('
                            + (orth.x * fontSize) + ' '
                            + (orth.y * fontSize) + ')')
                            : 'translate('
                            + (orth.x*2) + ' '
                            + (orth.y*2) + ')';
                    });
                    }, 100);
                }
              }
            });
            setTimeout(() => {
                groups.on("mouseover", function(d,i){
                  if(!running){
                svg.select("#circle"+i)
                .transition()
                .duration(250)
                .attr("stroke", "#FF3D2E")
                .attr("stroke-width", "10px"); 
              }
            });
            groups.on("mouseout", function(d,i){
              if(!running){
                if(!drawing){
                    svg.select("#circle"+i)
                    .transition()
                    .duration(250)
                    .attr("stroke", "black")
                    .attr("stroke-width", "5px"); 
                }
                else{
                    svg.select("#circle"+i)
                    .transition()
                    .duration(250)
                    .attr("stroke-width", "5px"); 
                }
              }
            });
            }, 510);
            
            setTimeout(() => {  
                resolve();
            }, 350);    
        });
    }

    function isFiniteNumber(x) {
    return typeof x === 'number' && (Math.abs(x) < Infinity);
}

function isVector(v) {
    return isFiniteNumber(v.x) && isFiniteNumber(v.y);
}
    async function newEdge(v1,v2){
        return new Promise(resolve => {
            var xy_0 = data_nodes[v1];
            var xy_1 = data_nodes[v2];

            var line = d3.line()
                .x(function(d) { return d.x; })
                .y(function(d) { return d.y; })
                .curve(d3.curveLinear); 
            
            if(!g.edgeExists(data_nodes[v1], data_nodes[v2])){
                g.addEdge({x:data_nodes[v1].x, y:data_nodes[v1].y, id:v1}, {x:data_nodes[v2].x, y:data_nodes[v2].y, id:v2});
                svg.select("#g-paths").append("path")
                    .transition()
                    .duration(300)
                    .attr("d", line([xy_0,xy_1]))
                    .attr("stroke", "#272F32")
                    .attr("stroke-width", 4)
                    .attr("fill", "none")
                    .attr("id", function(d,i){
                        data_edges.push({v1:v1, v2:v2, id:data_edges.length});
                        return "path"+(data_edges.length-1);
                    });
                var text = svg.append("g").attr("id", "text-path-"+v1+""+v2)
                    .append("text")
                    .append("textPath") //append a textPath to the text element
                    .attr("xlink:href", "#path"+(data_edges.length-1)) //place the ID of the path here
                    .style("text-anchor","middle") //place the text halfway on the arc
                    .attr("startOffset", "50%")
                    .attr("font-size", "18px")
                    .attr("font-weight", "bold")
                    .text(g.getEdgeLength(v1,v2));
            }
        setTimeout(() => {
             
            resolve();
        }, 300);
            
        });
    }

    async function findEdgeForAnim(qe, nb){
        return new Promise(resolve => {
            for (var i in data_edges) {
                var stop = false;
                if((data_edges[i].v1 == qe && data_edges[i].v2 == nb) 
                    || (data_edges[i].v1 == nb && data_edges[i].v2 == qe) ){
                    d3.select("#path"+data_edges[i].id)
                    .transition()
                    .duration(DELAY)
                    .attr("stroke", "#FF3D2E"); 
                                                                                      
                    setTimeout(() => {
                        resolve(i);
                    }, DELAY*2); 
                    break;
                }
            };    
        }, 1000);
    }

    function highlightCode(elementClass){
        $(".code-highlight").removeClass("code-highlight");
        $(`.${elementClass}`).addClass("code-highlight");
    }

    async function timeout(delay){
        await new Promise(resolve =>
            setTimeout(() => {  	
                resolve();            
            }, delay)               
        );
    }

    function find(parent, i){
        if(parent[i] == i) return i;

        return this.find(parent, parent[i]);
    }

    function union(parent, rank, x, y){
        var xroot = find(parent, x) 
        var yroot = find(parent, y) 

        if(rank[xroot] < rank[yroot]){ 
            parent[xroot] = yroot 
        }
        else if (rank[xroot] > rank[yroot]){ 
            parent[yroot] = xroot 
        }
        else{
            parent[yroot] = xroot 
            rank[xroot] += 1
        }
    }

    function seen(seenEdges, check){
        for (const i in seenEdges) {
            if (seenEdges[i][0] == check[0] && seenEdges[i][1] == check[1]) {
                return true;  
            }
        }
        return false;
    }


    async function kruskals(){
        $("#start-button").prop("disabled",true);
        $(".button-top").prop("disabled",true);
        running = true;
        var q = [];
        var result = [];
        var graph = g;
        var len = 0;
        d3.selectAll("circle,path").attr("stroke", "#999");
        
        var parent = [];
        var rank = [];
        var seenEdges = [];
        for (let i = 0; i < graph.adjList.size; i++) {
            parent.push(i);
            rank.push(0);
            var nbs = graph.adjList.get(i);
            for (let j = 0; j < nbs.length; j++) {
                if(!seen(seenEdges, [i, nbs[j].id])){
                    nbs[j].v1 = i;
                    seenEdges.push([nbs[j].id, i])
                }
                else{
                  nbs[j].rem = true;
                }
            }
            q = q.concat(nbs);
        }

        for (let i = 0; i < q.length; i++) {
          if (q[i].rem == true) {
            q.splice(i,1);
            i-= 1;
          }
        }
        q = q.sort((a, b) => (a.len > b.len) ? 1 : -1);
        
        while(result.length < graph.getNoOfVertices()-1){
            var nextEdge = q.shift();
            d3.select("#circle"+nextEdge.v1)
            .transition()
            .duration(DELAY)
            .attr("stroke", "#FF3D2E")
            .attr("stroke-width", "10px");
            d3.select("#circle"+nextEdge.id)
            .transition()
            .duration(DELAY)
            .attr("stroke", "#FF3D2E")
            .attr("stroke-width", "10px");
             

            await findEdgeForAnim(nextEdge.v1, nextEdge.id);
            var x = find(parent, nextEdge.v1);
            var y = find(parent, nextEdge.id);

            if(x != y){
              d3.select("#circle"+nextEdge.v1)
                  .attr("class", "MST")
              d3.select("#circle"+nextEdge.id)
                  .attr("class", "MST")
              for (var i in data_edges) {
                if((data_edges[i].v1 == nextEdge.v1 && data_edges[i].v2 == nextEdge.id) 
                    || (data_edges[i].v1 == nextEdge.id && data_edges[i].v2 == nextEdge.v1) ){
                    d3.select("#path"+data_edges[i].id)
                    .attr("class", "MST"); 
                  }
                }
                len += nextEdge.len;
                result.push(nextEdge);
                union(parent, rank, x, y)
            }
            else{
              d3.select("#circle"+nextEdge.v1)
                    .filter(function() {
                        return !this.classList.contains('MST')
                    })
                  .transition()
                  .duration(DELAY)
                  .attr("stroke", "#DDD")
                  .attr("stroke-width", "5px"); 
              d3.select("#circle"+nextEdge.id)
                    .filter(function() {
                        return !this.classList.contains('MST')
                    })
                  .transition()
                  .duration(DELAY)
                  .attr("stroke", "#DDD")
                  .attr("stroke-width", "5px"); 
            }
            for (var i in data_edges) {
                if((data_edges[i].v1 == nextEdge.v1 && data_edges[i].v2 == nextEdge.id) 
                    || (data_edges[i].v1 == nextEdge.id && data_edges[i].v2 == nextEdge.v1) ){
                    d3.select("#path"+data_edges[i].id)
                    .filter(function() {
                        return !this.classList.contains('MST')
                    })
                    .transition()
                    .duration(DELAY)
                    .attr("stroke", "#DDD"); 
                }
            }
        }
        for (var i in data_edges) {
            d3.select("#path"+data_edges[i].id)
                .filter(function() {
                    return !this.classList.contains('MST')
                })
                .transition()
                .duration(DELAY/10)
                .attr("stroke", "#DDD"); 
        }
        $("#nodes").html("Length of the MST: " + len);

        running = false;
        $("#start-button").prop("disabled",false);
        $(".button-top").prop("disabled",false);
    }

    function clearCanvas(){
        data_edges = [];
        data_nodes = [];
        vertexCount = 0;
        g = new WeightedUndirectedGraph();
        drawing = false;

        svg.selectAll("*").remove();
        svg.append("g").attr("id", "g-paths")
    }

    function getRowCol(numVerts, taken) {
        row = Math.round(Math.random()*(numVerts-1));
        col = Math.round(Math.random()*(numVerts-1));

        while (taken[row][col]) {
            row = Math.round(Math.random()*(numVerts-1));
            col = Math.round(Math.random()*(numVerts-1));
        }

        taken[row][col] = true;

        return({row:row, col:col, taken:taken});

    }

    async function randomGraph(){
      if(!drawGraph){  
        drawGraph = true;
        var numberVerts = Math.round((Math.random()*4)+4);
        var maxEdges = numberVerts*(numberVerts-1)/2;
        var numberEdges = Math.round((Math.random()*(maxEdges-numberVerts))+numberVerts);
        var cellHeight = Math.round(h/6);
        var cellWidth = Math.round(w/6);
        var row = 0;
        var col = 0;
        var x = 0;
        var y = 0;
        var v1;
        var v2;
        var taken = [];
        
        for (let x = 0; x < 6; x++) {
            var row = [];
            for (let y = 0; y < 6; y++) { 
                row.push(false);                
            }
            taken.push(row);
        }

        clearCanvas();

        for (let i = 0; i < numberVerts; i++) {
            var rowcol = getRowCol(6, taken);
            row = rowcol.row;
            col = rowcol.col;
            taken = rowcol.taken;

            x = Math.round((cellWidth*col)+Math.random()*25);
            y = Math.round((cellHeight*row)+Math.random()*25);
            await newVertex([x,y]);
        }
        
        for (let j = 0; j < numberEdges; j++) {
            v1 = Math.round(Math.random()*(numberVerts-1));
            v2 = Math.round(Math.random()*(numberVerts-1));
            let breaker = 0;

            while (v1 == v2 || g.edgeExists(v1,v2)) {
                if(breaker < 100){
                    v2 = Math.round(Math.random()*(numberVerts-1));
                }
                else{
                  break;
                }
                breaker++;
            }
            if(breaker < 100) await newEdge(v1, v2);  
            svg.select("#text-path-"+v1+""+v2).attr('transform', function(d) {
                        if (!(isVector(data_nodes[v1]) && isVector(data_nodes[v2]))) {
                            return '';
                        }
                        // Get the geometric center of this element
                        var box = this.getBBox();
                        var center = {
                            x: box.x + box.width / 2,
                            y: box.y + box.height / 2
                        };

                        // Get the vector of the link
                        var delta = {
                            x: data_nodes[v2].x - data_nodes[v1].x,
                            y: data_nodes[v2].y - data_nodes[v1].y
                        };

                        // Get a unitary vector orthogonal to delta
                        var norm = Math.sqrt(delta.x * delta.x + delta.y * delta.y);
                        var orth = {
                            x: delta.y/norm,
                            y: -delta.x/norm
                        };

                        // Replace this with your ACTUAL font size
                        var fontSize = 18;

                        // Flip the text and translate it beyond the link line
                        // if the link goes towards the left
                        return delta.x < 0
                            ? ('rotate(180 '
                            + center.x
                            + ' ' + center.y
                            + ') translate('
                            + (orth.x * fontSize) + ' '
                            + (orth.y * fontSize) + ')')
                            : 'translate('
                            + (orth.x*2) + ' '
                            + (orth.y*2) + ')';
                    }) 
        }
        drawGraph = false;
      }
    }
  </script>

<script>
    $(document).ready(function() {
      d3.select("#visu").attr("width", "100%").attr("height", "370").attr("viewBox", "0 0 "+ globalThis.screen.availWidth + " 370");
     
      var speedSlider = new Slider("#speedslider",{
          reversed : true,
        tooltip : "none",
        handle : "square"
      });
  
      speedSlider.on("slide", function(slideEvt) {
        setDelay(slideEvt);
      });
  
    });
    
</script>
  

  </body>
  </html>